#!/usr/bin/env python

from __future__ import print_function
import argparse
import contextlib
import signal
import subprocess
import sys
import tempfile
import uuid
import math
import os

from distutils.spawn import find_executable
from os.path import join, realpath, exists, dirname
from os import remove, mkfifo
from shutil import rmtree

def ext_check(*args):
    def extension(filename):
        for a in args:
            if filename.endswith(a):
                return filename
        raise ValueError
    return extension

def mem_check(mem):
    if mem[-1] not in {"K", "M", "G"}:
        raise ValueError
    mult = {"G": 1e6, "M": 1e3, "K": 1}
    return int(mem[:-1]) * mult[mem[-1]]

script_path = realpath(dirname(__file__))

fumi_dedup = join(script_path, "fumi_tools_dedup") if exists(join(script_path, "fumi_tools_dedup")) else "fumi_tools_dedup"
fumi_fix = join(script_path, "fumi_tools_fix_flags") if exists(join(script_path, "fumi_tools_fix_flags")) else "fumi_tools_fix_flags"
fumi_copy_umi = join(script_path, "fumi_tools_copy_umi") if exists(join(script_path, "fumi_tools_copy_umi")) else "fumi_tools_copy_umi"
fumi_demultiplex = join(script_path, "fumi_tools_demultiplex") if exists(join(script_path, "fumi_tools_demultiplex")) else "fumi_tools_demultiplex"

if find_executable(fumi_dedup) is None or find_executable(fumi_fix) is None or find_executable(fumi_copy_umi) is None or find_executable(fumi_demultiplex) is None:
    print("It seems that your installation is broken. Please reinstall the tool.")
    sys.exit(1)


VERSION = subprocess.check_output([fumi_dedup, "--version"]).decode()
VERSION_NUMBER = VERSION[VERSION.find(' ')+1:]

class fumi_tools(object):
    def __init__(self):
        parser = argparse.ArgumentParser(
            usage="""fumi_tools <command> [<args>]
Version: {}

Available commands are:
    demultiplex  Demultiplex single FASTQ file
    copy_umi     Copy UMI from FASTQ files into their header
    dedup        Deduplicate reads in BAM files
""".format(VERSION_NUMBER))
        parser.add_argument("command", help="Subcommand to run")
        args = parser.parse_args(sys.argv[1:2])
        if not hasattr(self, args.command):
            print("Unrecognized command: " + sys.argv[1] + "\n")
            parser.print_help()
            sys.exit(1)
        getattr(self, args.command)()
        self.command = args.command

    def demultiplex(self):
        FQ_EXTS = [".fastq", ".fq"]
        COMPR = ["", ".gz"]
        VALID_EXTS = ["{}{}".format(fq, c) for fq in FQ_EXTS for c in COMPR]
        parser = argparse.ArgumentParser(prog="fumi_tools demultiplex", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
        parser.add_argument("-i", "--input", help="Input FASTQ file, optionally gzip compressed.", required=True, type=ext_check(*VALID_EXTS), default=argparse.SUPPRESS)
        parser.add_argument("-s", "--sample-sheet", help="Sample Sheet in Illumina format.", required=True)
        parser.add_argument("-o", "--output", help="Output FASTQ file pattern, optionally gzip compressed. Use %i as placeholder for the sample index specified in the sample sheet, %s for the sample name and %l for the lane (e.g. demultiplexed_reads/%s_S%i_L%l_R1.fastq.gz).", required=True, type=ext_check(*VALID_EXTS), default=argparse.SUPPRESS)
        parser.add_argument("-e", "--max-errors", help="Maximum allowed number of errors (mismatches per default).", type=int, default=1)
        parser.add_argument("-l", "--lane", help="Optionally specify on which lane the samples provided in the sample sheet ran. Can be specified multiple times to pass several lanes. This option takes precedence on the Lane column of the sample sheet.",
                            nargs='+', action='extend', type=str)
        parser.add_argument("--format-umi", help="Add UMI to the end of the FASTQ header, as expected by fumi_tools dedup", action="store_true")
        parser.add_argument("--threads", help="Number of threads to use.", default=1, type=int)
        parser.add_argument("--version", help="Display version number.", action='version', version=VERSION)
        self.c_args = parser.parse_args(sys.argv[2:])

    def copy_umi(self):
        FQ_EXTS = [".fastq", ".fq"]
        COMPR = ["", ".gz", ".bz2", ".xz"]
        VALID_EXTS = ["{}{}".format(fq, c) for fq in FQ_EXTS for c in COMPR]
        parser = argparse.ArgumentParser(prog="fumi_tools copy_umi", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
        parser.add_argument("-i", "--input", help="Input FASTQ file, optionally gzip, bz2 or xz compressed.", required=True, type=ext_check(*VALID_EXTS), default=argparse.SUPPRESS)
        parser.add_argument("-I", "--input-read2", help="Input paired end R2 FASTQ file, optionally gzip, bz2 or xz compressed.", required=False, type=ext_check(*VALID_EXTS), default=argparse.SUPPRESS)
        parser.add_argument("-o", "--output", help="Output FASTQ file, optionally gzip, bz2 or xz compressed.", required=True, type=ext_check(*VALID_EXTS), default=argparse.SUPPRESS)
        parser.add_argument("-O", "--output-read2", help="Output paired end R2 FASTQ file, optionally gzip, bz2 or xz compressed.", required=False, type=ext_check(*VALID_EXTS), default=argparse.SUPPRESS)
        parser.add_argument("--umi-length", help="Length of the UMI to copy. It is assumed that the UMI starts at the 5' end of the read.", type=int, required=True)
        parser.add_argument("--threads", help="Number of threads to use.", default=1, type=int)
        parser.add_argument("--version", help="Display version number.", action='version', version=VERSION)
        self.c_args = parser.parse_args(sys.argv[2:])

    def dedup(self):
        parser = argparse.ArgumentParser(prog="fumi_tools dedup", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
        parser.add_argument("-i", "--input", help="Input SAM or BAM file. Needs to be coordinate sorted.", required=True, type=ext_check(".bam", ".sam", "-"), default=argparse.SUPPRESS)
        parser.add_argument("-o", "--output", help="Output SAM or BAM file, sorted by read name. To output SAM on stdout use '-'.", required=True, type=ext_check(".bam", ".sam", "-"), default=argparse.SUPPRESS)
        parser.add_argument("--paired", help="Specify this option if your input contains paired end reads", action='store_true')
        parser.add_argument("--start-only", help="Reads only need the same start position and the same UMI to be considered duplicates.", action='store_true')
        parser.add_argument("--chimeric-pairs", help="How to handle chimeric read pairs. (discard|use)", default="use", choices=["discard", "use"], nargs='?', const='use')
        parser.add_argument("--unpaired-reads", help="How to handle unpaired reads (e.g. mate did not align) (discard|use)", default="use", choices=["discard", "use"], nargs='?', const='use')
        parser.add_argument("--sort-adjacent-pairs", help="Keep name sorting, but sort pairs such that the mate always follows the first read.", action='store_true')
        parser.add_argument("--threads", help="Number of threads to use.", default=1, type=int)
        parser.add_argument("--memory", help="Maximum memory used for sorting. Units can be K/M/G.", default="3G", type=mem_check)
        parser.add_argument("--seed", help="Random number generator seed.", default=42, type=int)
        parser.add_argument("--version", help="Display version number.", action='version', version=VERSION)
        self.c_args = parser.parse_args(sys.argv[2:])


def demultiplex(args):
    if not exists(dirname(args.output)):
        os.makedirs(dirname(args.output))
    try:
        if args.lane:
            lane_arg = ["--lane={}".format(l) for l in args.lane]
        else:
            lane_arg = ""
        result = subprocess.check_output([fumi_demultiplex, "--input", args.input,
                                          "--sample-sheet", args.sample_sheet,
                                          "--output", args.output,
                                          "--max-errors", str(args.max_errors),
                                          "--threads", str(args.threads),
                                          "--format-umi" if args.format_umi else "",
                                          *lane_arg], stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as e:
        print("Demultiplexing file failed with code ({})!".format(e.returncode), file=sys.stderr)
        print(e.output.decode(), file=sys.stderr)
        return e.returncode
    return 0


def copy_umi(args):
    if hasattr(args, 'input_read2'):
        try:
            result = subprocess.check_output([fumi_copy_umi, "-i", args.input, "-I", args.input_read2, "-o", args.output, "-O", args.output_read2, "--umi-length", str(args.umi_length), "--threads", str(args.threads)], stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Extracting UMI failed with code ({})!".format(e.returncode), file=sys.stderr)
            print(e.output.decode(), file=sys.stderr)
            if exists(args.output):
                remove(args.output)
            if exists(args.output_read2):
                remove(args.output_read2)
            return e.returncode
        return 0
    else:
        try:
            result = subprocess.check_output([fumi_copy_umi, "-i", args.input, "-o", args.output, "--umi-length", str(args.umi_length), "--threads", str(args.threads)], stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Extracting UMI failed with code ({})!".format(e.returncode), file=sys.stderr)
            print(e.output.decode(), file=sys.stderr)
            if exists(args.output):
                remove(args.output)
            if exists(args.output_read2):
                remove(args.output_read2)
            return e.returncode
        return 0
        

def dedup(args):
    ithreads = str(min(2, args.threads))
    sort_threads = args.threads
    memory_per_thread = str(int(args.memory / args.threads)) + "K"

    dedup_process = subprocess.Popen([fumi_dedup, "--input", args.input,
                                                "--output=-",
                                                "--start-only" if args.start_only else "",
                                                "--seed", str(args.seed),
                                                "--paired" if args.paired else "",
                                                "--chimeric-pairs={}".format(args.chimeric_pairs) if args.paired else "",
                                                "--unpaired-reads={}".format(args.unpaired_reads) if args.paired else "",
                                                "--uncompressed",
                                                "--input-threads", ithreads], stdout=subprocess.PIPE)
    sort_process = subprocess.Popen(["samtools", "sort", "-n", "-l0", "-@", str(sort_threads), "-m", memory_per_thread], stdin=dedup_process.stdout, stdout=subprocess.PIPE)
    fix_process = subprocess.Popen([fumi_fix, "--input=-",
                                            "--output", args.output,
                                            "--sort-adjacent-pairs" if args.sort_adjacent_pairs else "",
                                            "--input-threads", ithreads,
                                            "--output-threads", str(args.threads)], stdin=sort_process.stdout)
    dedup_process.stdout.close()
    sort_process.stdout.close()
    output = fix_process.communicate()[0]

    if fix_process.wait() != 0:
        print("Fixing flags for file '{}' failed!".format(args.output), file=sys.stderr)
        # if there is a failure here need to send a signal to both other processes
        sort_process.send_signal(signal.SIGTERM)
        dedup_process.send_signal(signal.SIGTERM)
        if exists(args.output):
            remove(args.output)
        return fix_process.returncode
    # no need to send signals to the other processes here
    if sort_process.wait() != 0:
        print("Sorting deduplicated file failed!", file=sys.stderr)
        if exists(args.output):
            remove(args.output)
        return sort_process.returncode
    if dedup_process.wait() != 0:
        print("Deduplicating file '{}' failed".format(args.input), file=sys.stderr)
        if exists(args.output):
            remove(args.output)
        return dedup_process.returncode

    return 0


# remove output file if we interrupt or kill this process
def handle_signal(args):
    def _(sig, frame):
        if exists(args.output):
            remove(args.output)
    return _

if __name__ == '__main__':
    args = fumi_tools()

    signal.signal(signal.SIGINT, handle_signal(args.c_args))
    signal.signal(signal.SIGTERM, handle_signal(args.c_args))

    if args.command == "copy_umi":
        sys.exit(copy_umi(args.c_args))
    elif args.command == "dedup":
        sys.exit(dedup(args.c_args))
    elif args.command == "demultiplex":
        sys.exit(demultiplex(args.c_args))
