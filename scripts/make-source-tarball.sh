#!/usr/bin/env bash
#
# Create a source tarball that includes submodule code and version.hpp.
# Intended to be called by semantic-release via @semantic-release/exec.
#
# Usage: scripts/make-source-tarball.sh <version>
#
# Prerequisites:
#   - Checkout must include submodules (git clone --recursive)

set -euo pipefail

VERSION="${1:?Usage: make-source-tarball.sh <version>}"

# Split version into components
IFS='.' read -r VERSION_MAJOR VERSION_MINOR VERSION_PATCH <<< "$VERSION"

SOURCE_DIR="$(cd "$(dirname "$0")/.." && pwd)"
STAGING="/tmp/fumi_tools-${VERSION}"

# Copy source tree, strip .git directories and unnecessary files
rm -rf "$STAGING"
cp -r "$SOURCE_DIR" "$STAGING"
find "$STAGING" -type d -name .git -exec rm -rf {} +
rm -rf "$STAGING/node_modules" "$STAGING/dist" "$STAGING/.releaserc"

# Generate version.hpp from template
cat > "$STAGING/include/fumi_tools/version.hpp" <<EOF

// ---------------------------------------------------
// This file is autogenerated by make-source-tarball.sh.
// DO NOT MODIFY!
// ---------------------------------------------------

#pragma once
#ifndef FUMI_TOOLS_VERSION_H
#define FUMI_TOOLS_VERSION_H

namespace version {
  constexpr const char* VERSION_STRING = "${VERSION}";
  constexpr const char* GIT_TAG_NAME = "${VERSION}";
  constexpr const unsigned int GIT_COMMITS_SINCE_TAG = 0;
  constexpr const char* GIT_COMMIT_ID = "release";
  constexpr bool MODIFIED_SINCE_COMMIT = false;

  constexpr const char* VERSION_COMPONENTS[] = {"${VERSION_MAJOR}", "${VERSION_MINOR}", "${VERSION_PATCH}"};
}

#endif

EOF

# Create tarball
mkdir -p "${SOURCE_DIR}/dist"
tar czf "${SOURCE_DIR}/dist/fumi_tools-${VERSION}.tar.gz" -C /tmp "fumi_tools-${VERSION}"

rm -rf "$STAGING"
echo "Created dist/fumi_tools-${VERSION}.tar.gz"
